Como partimos con breeze, esto nos genera las tablas necesarias para trabajar con un login, pero es necesario adaptarla a las necesidades del proyecto por lo tanto lo primero es modificar, dicha tabla.

## ğŸ§± SecciÃ³n: ConfiguraciÃ³n inicial de migraciones (con Breeze)

Una vez finalizada la instalaciÃ³n del stack de Laravel Breeze (`php artisan breeze:install blade`), Laravel nos genera automÃ¡ticamente una estructura mÃ­nima funcional para autenticaciÃ³n.

---

### ğŸ” Â¿QuÃ© tablas crea Breeze por defecto?

Al ejecutar `php artisan migrate` justo despuÃ©s de instalar Breeze, se crean las siguientes tablas:

| Tabla                    | PropÃ³sito                                                     | Editar      |
| ------------------------ | ------------------------------------------------------------- | ----------- |
| `users`                  | Tabla principal de usuarios del sistema                       | _Se edita_  |
| `password_reset_tokens`  | Tokens de recuperaciÃ³n de contraseÃ±a                          | sin edicion |
| `sessions`               | GestiÃ³n de sesiones de usuario (opcional segÃºn configuraciÃ³n) | sin edicion |
| `personal_access_tokens` | Tokens de acceso para APIs (usado por Sanctum, opcional)      | si edecion  |

---

## âš™ï¸ Adaptando las migraciones al modelo de la empresa

Como nuestro objetivo es adaptar el proyecto a la estructura de base de datos definida por la empresa, el **primer paso es modificar la tabla** `**users**`.

Laravel ya generÃ³ una migraciÃ³n con esta tabla, por lo tanto:

### âœ… No es necesario crear una nueva migraciÃ³n.

Podemos modificar directamente el archivo:

```
database/migrations/xxxx_xx_xx_xxxxxx_create_users_table.php
```

Al abrir este archivo, verÃ¡s que contiene varias estructuras `Schema::create()` en un solo bloque, por ejemplo:

```
Schema::create('users', function (Blueprint $table) {
    $table->id();
    $table->string('name');
    $table->string('email')->unique();
    $table->timestamp('email_verified_at')->nullable();
    $table->string('password');
    $table->rememberToken();
    $table->timestamps();
});
```

Justo allÃ­ es donde debÃ©s **editar o agregar los campos necesarios** para igualar la estructura del modelo de usuarios de la empresa.

---

## âœï¸ Â¿CÃ³mo editar la migraciÃ³n?

1. Buscar dentro del archivo la secciÃ³n `Schema::create('users'...`.
    
2. Agregar/modificar los campos necesarios, por ejemplo:
    

```
$table->id();
$table->string('name');
$table->string('email')->unique();
$table->timestamp('email_verified_at')->nullable();
$table->string('password');
$table->string('rol', 250)->nullable();
$table->string('cliente', 250)->nullable();
$table->integer('cliente_id')->nullable();
$table->string('status', 250)->nullable();
$table->rememberToken();
$table->timestamps();
```

Esto reemplaza la estructura base generada por Breeze por una adaptada a tu modelo.

---

## ğŸš€ Â¿CÃ³mo aplicamos los cambios?

### Si el proyecto estÃ¡ reciÃ©n comenzando (sin datos):

UsÃ¡ este comando para eliminar todas las tablas y ejecutar todas las migraciones nuevamente:

```
php artisan migrate:fresh
```

Este comando:

- ğŸ”¥ Elimina todas las tablas existentes
    
- ğŸ§± Ejecuta todas las migraciones desde cero
    

âœ… Ideal si aÃºn no hay datos que perder.

---
>Importante: lo que viene a continuaciÃ³n  es solo para el aprendizaje, es muy importante entender que perfectamente esto podrÃ­a ser una importaciÃ³n de la base de datos, pero... _Â¿CÃ³mo aprenderemos si no lo hacemos_ ... recuerda siempre ** Comete la rana primero **
>
## ğŸ—ƒï¸ HomologaciÃ³n SQL âœ Laravel Schema Builder

Cuando estamos convirtiendo una base de datos existente en SQL a migraciones de Laravel, es Ãºtil tener una tabla de referencia que nos indique cÃ³mo traducir cada tipo de campo.

A continuaciÃ³n se presenta un ejemplo prÃ¡ctico usando la tabla `temporadas_usos`:

### ğŸ§¾ SQL Original

```
CREATE TABLE `temporadas_usos` (
  `id` bigint(20) UNSIGNED NOT NULL,
  `fecha_inicio` date NOT NULL,
  `fecha_termino` date NOT NULL,
  `temporada` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

---

### ğŸ› ï¸ Equivalente en migraciÃ³n Laravel

```
Schema::create('temporadas_usos', function (Blueprint $table) {
    $table->id(); // bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY
    $table->date('fecha_inicio'); // date NOT NULL
    $table->date('fecha_termino'); // date NOT NULL
    $table->string('temporada'); // varchar(255) NOT NULL
    $table->timestamps(); // created_at y updated_at como timestamp NULL DEFAULT NULL
});
```

---

## ğŸ“˜ Tabla de HomologaciÃ³n Completa SQL âœ Laravel

| SQL (tipo de dato)                 | Laravel Schema Builder                                     | Notas                                                          |
| ---------------------------------- | ---------------------------------------------------------- | -------------------------------------------------------------- |
| `BIGINT`                           | `$table->bigInteger('campo');`                             | Usar `.unsigned()` si aplica                                   |
| `BIGINT UNSIGNED`                  | `$table->bigInteger('campo')->unsigned();`                 | Para valores positivos (ej. IDs relacionados)                  |
| `INT`                              | `$table->integer('campo');`                                | Entero normal                                                  |
| `INT UNSIGNED`                     | `$table->integer('campo')->unsigned();`                    |                                                                |
| `TINYINT(1)`                       | `$table->boolean('campo');`                                | Laravel lo interpreta como `true/false`                        |
| `DECIMAL(8,2)`                     | `$table->decimal('campo', 8, 2);`                          | Ideal para precios, montos, etc.                               |
| `FLOAT`                            | `$table->float('campo', 8, 2);`                            | Similar a decimal pero menos preciso                           |
| `DOUBLE`                           | `$table->double('campo', 8, 2);`                           | MÃ¡s precisiÃ³n que float                                        |
| `VARCHAR(255)`                     | `$table->string('campo');`                                 | Por defecto es 255 caracteres                                  |
| `VARCHAR(n)`                       | `$table->string('campo', n);`                              | Puedes especificar otro tamaÃ±o                                 |
| `CHAR(n)`                          | `$table->char('campo', n);`                                | Para cadenas de longitud fija                                  |
| `TEXT`                             | `$table->text('campo');`                                   | Texto largo                                                    |
| `MEDIUMTEXT` / `LONGTEXT`          | `$table->mediumText()` / `$table->longText()`              | Para textos aÃºn mÃ¡s extensos                                   |
| `DATE`                             | `$table->date('campo');`                                   | Fecha sin hora                                                 |
| `DATETIME`                         | `$table->dateTime('campo');`                               | Fecha con hora completa                                        |
| `TIMESTAMP`                        | `$table->timestamp('campo');`                              | Fecha/hora que puede usarse para control automÃ¡tico de cambios |
| `TIMESTAMP NULL DEFAULT NULL`      | `$table->timestamps();`                                    | Agrega `created_at` y `updated_at`                             |
| `ENUM('a','b')`                    | `$table->enum('campo', ['a', 'b']);`                       | Se recomienda usar con cuidado                                 |
| `SET('a','b')`                     | **no tiene soporte directo**                               | Se puede usar un string y manejarlo manualmente                |
| `BOOLEAN`                          | `$table->boolean('campo');`                                | true/false                                                     |
| `JSON`                             | `$table->json('campo');`                                   | Para guardar datos estructurados                               |
| `BLOB` / `MEDIUMBLOB` / `LONGBLOB` | `$table->binary('campo');`                                 | Para archivos binarios                                         |
| `PRIMARY KEY`                      | `$table->primary('campo');`                                | Puedes definir claves primarias manualmente                    |
| `UNIQUE`                           | `$table->unique('campo');`                                 | Agrega restricciÃ³n de unicidad                                 |
| `INDEX`                            | `$table->index('campo');`                                  | Agrega Ã­ndice simple                                           |
| `FOREIGN KEY`                      | `$table->foreign('campo')->references('id')->on('tabla');` | Llave forÃ¡nea, relaciÃ³n entre tablas                           |

---

> ğŸ§  RecordÃ¡ que podÃ©s agregar:
> 
> - `.nullable()` para permitir valores nulos
>     
> - `.default('valor')` para valores por defecto
>     

```
$table->string('estado')->nullable()->default('activo');
```

---

Â¿QuerÃ©s convertir mÃ¡s tablas SQL a Laravel paso a paso? Podemos agregar mÃ¡s ejemplos prÃ¡cticos en esta misma entrada.